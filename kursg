#!/usr/bin/env bash

#  ==========================================================================
#   Licensed under BSD 2clause license. See LICENSE file for more information
#   Author: Michał Łyszczek <michal.lyszczek@bofc.pl>
#  ==========================================================================

#
# functions and stuff
#

function show_help
{
    echo "kursg [options]"
    echo ""
    echo -e "\t-h        print this help message"
    echo -e "\t-i<path>  directory to process"
    echo -e "\t-o>path>  output directory"
    echo -e "\t-d        delete output directory before generating"
}

#
# builds index of all html files
#

function build_index
{
    local o="${1}"  # absolute path to file where index will be printed
    local d="${2}"  # depth of generated file in regard of root

    local prefix="./"

    #
    # make all echo redirect to $o file
    #

    exec 1<&-
    exec 1<>"${o}"

    #
    # truncate file if it already exists
    #

    truncate -s0 "${o}"

    ###
    # generate relative prefix for css content
    #

    for c in $(seq 1 1 ${d})
    do
        prefix+="../"
    done

    #
    # build index and meta information from index.in
    #

    echo '<!DOCTYPE html>'
    echo '<html lang="'${in_lang}'">'
    echo '<head>'
    echo '<title>'$in_title'</title>'
    echo '<link rel="stylesheet" type="text/css; charset=utf-8" href="'${prefix}'style.css">'
    echo '<link rel="stylesheet" type="text/css" href="'${prefix}'pygment.css">'

    if [ -f "${in}/custom.css" ]
    then
        echo '<link rel="stylesheet" type="text/css" href="'${prefix}'custom.css">'
    fi

    echo '<meta charset="UTF-8">'
    echo '<meta name="description" content="'${in_description}'">'
    echo '<meta name="keywords" content="'${in_keywords}'">'
    echo '<meta name="author" content="'${in_author}'">'
    echo '</head>'
    echo '<body>'
    echo '<div id="header">'

    #
    # print user defined header (logo or something like that)
    #

    cat "${in}/header.in"

    echo '</div>'

    #
    # restore echo output
    #

    exec &>/dev/tty
}


function close_index
{
    o="${1}"  # absolute path to file where index will be printed

    echo '</body>' >> "${o}"
    echo '</html>' >> "${o}"

    #
    # restore echo output
    #

    exec &>/dev/tty
}

get_kursg_meta()
{
    file="${1}"
    field="${2}"

    ext="${file##*.}"
    skip_last_chars=0

    if [ "${ext}" = "md" ]
    then
        tmp="$(grep "^\[kursg-meta\]: # (${field}: " "${file}" | awk '{print $4}')"
        skip_last_chars=1
    elif [ "${ext}" = "html" ] || [ "${ext}" = "htm" ]
    then
        tmp="$(grep "^<\!-- \[kursg-meta:${field}\]" "${file}" | cut -f3- -d\ )"
        skip_last_chars=4
    elif [ -d "${file}" ]
    then
        tmp="$(grep "^${field}:" "${file}/.kursg-info" 2>/dev/null | cut -f2- -d\ )"
        skip_last_chars=0
    else
        ###
        # file extension not recognized, exit
        #

        return
    fi

    if [ -z "${tmp}" ]
    then
        ###
        # field wasn't found, return nothing
        #
        return
    fi

    ###
    # echo value and strip trailing ')'
    #

    if [ $skip_last_chars -eq 0 ]
    then
        echo "${tmp}"
    else
        echo ${tmp:0:-${skip_last_chars}}
    fi
}

get_meta_title()
{
    file="${1}"

    title="$(get_kursg_meta "${file}" "title")"

    if [ ! -z "${title}" ]
    then
        echo "${title}"
        return
    fi

    ###
    # title wasn't set in file, use first h1 element (one with ===)
    #

    title="$(cat ${file} 2>/dev/null | grep "^=" -m1 -C1 | head -n1)"

    if [ ! -z "${title}" ]
    then
        echo "${title}"
        return
    fi

    ###
    # title wasn't set in file, out last hope is filename
    #

    basefile="$(basename ${file})"
    echo ${basefile%.*}
}

get_meta_order()
{
    file="${1}"

    order="$(get_kursg_meta "${file}" "order")"

    if [ -z "${order}" ]
    then
        ###
        # order was not set, apply maximum possible order and let it be sorted
        # alphabetically, after files that have order set
        #

        echo "9999"
        return
    fi

    printf "%04d" "${order}"
}

build_menu()
{
    local dname="${1}"
    local outfile="${2}"
    local depth="${3}"

    local menu=
    local dir=
    local prefix="./"
    local dirnum=0

    ###
    # generate relative prefix for site links
    #

    for c in $(seq 1 1 ${depth})
    do
        prefix+="../"
    done

    ###
    # a little hack to pass variable to piped while
    #

    echo "${prefix}" > /tmp/kursg-menu-prefix

    IFS=$'/'
    for d in ${dname}
    do
        dir+="${d}"
        ((dirnum++))

        menu+='<div class="menu">'
        menu+='<ul class="menu">'
        menu_links=

        cd "${in}/${dir}" 2> /dev/null
        find . -maxdepth 1 \( -name "*.md" -o -name "*.html" -o -type d \) -print0 | while IFS= read -r -d $'\0' f
        do
            f="$(basename "${f}")"
            file_title="$(get_meta_title "${f}")"
            file_order="$(get_meta_order "${f}")"
            file_name=${f%.*}
            prefix="$(cat /tmp/kursg-menu-prefix)"

            if [ -d "${f}" ]
            then
                if [ -f "${f}/.kursg-ignore" ] || [ "${f}" = "." ] || \
                   [ -f "${f}.md" ] || [ -f "${f}.html" ]
                then
                    continue
                fi

                file_name="${f}"
            fi

            path=$(echo "${dir}/${file_order}-${file_name}.html" | cut -c3-)
            path="${prefix}${path}"
            echo -n "<li class=\"menu\"><a class=\"menu\" href=\"${path}\">" >> /tmp/kursg-menu
            echo "${file_title}</a></li>" >> /tmp/kursg-menu
        done
        cd - > /dev/null
        IFS=$'/'

        sort /tmp/kursg-menu -o /tmp/kursg-menu
        sed -i '/<li class="menu"><a class="menu" href="/ { s/[0-9][0-9][0-9][0-9]-//g }' /tmp/kursg-menu
        menu+="$(cat /tmp/kursg-menu)"
        menu+='</ul>'
        menu+='</div>'
        menu+='<div class="content">'
        dir+='/'
        rm /tmp/kursg-menu
    done
    IFS=
    rm /tmp/kursg-menu-prefix

    echo "${menu}" >> "${outfile}"

    ###
    # return number of created <div class="content"> so upper layer can
    # close them all later when it has filled content with data
    #

    echo "${dirnum}"
}

is_ignored()
{
    local dir="${1}"

    while true
    do
        if [ -f "${dir}/.kursg-ignore" ]
        then
            return 0
        fi

        dir="$(dirname "${dir}")"

        if echo "${dir}" | grep -v '/' > /dev/null
        then
            ###
            # no more directories in path, do one more check and exit
            #

            if [ -f "${dir}/.kursg-ignore" ]
            then
                return 0
            fi

            return 1
        fi
    done
}


################################################################################
# the real code starts here
################################################################################


#
# parse input parameters
#

out="$(pwd)/kurwigen_out"
in="$(pwd)"
delete=0
OPTIND=1

while getopts "h?i:o:d" opt
do
    case "${opt}" in
    h|\?)
        show_help
        exit 0
        ;;

    i)
        in="$(pwd)/${OPTARG}"
        ;;

    o)
        out="$(pwd)/${OPTARG}"
        ;;

    d)
        delete=1
        ;;
    esac
done

#
# source config file
#

. "${in}/index.in"

#
# checking for program
#

markdown_extensions="-x markdown.extensions.fenced_code -x markdown.extensions.codehilite -x markdown.extensions.toc -x markdown.extensions.admonition -x markdown.extensions.tables"
markdown=$(which markdown_py)

if [ ! -x "${markdown}" ]
then
    echo "python markdown (markdown_py) was not found on the system"
    exit 1
fi

markdown="${markdown} ${markdown_extensions}"

#
# sanity check of output directory
#

if [ ${delete} -eq 1 ]
then
    echo "Do you want to delete ${out} directory recursively? Type 'yes' if so."
    read answer

    if [ "x$answer" = "xyes" ]
    then
        rm -rf $out
    fi
fi

[ -d "${out}" ] || mkdir "${out}"

###
# add .kursg-ignore to out directory, so we don't include it in parsing,
# we will remove it after parsing
#

touch "${out}/.kursg-ignore"

#
# look for resource directory
#

res=

if [ -d "/usr/share/kursg" ]
then
    res="/usr/share/kursg"

elif [ -d "/usr/local/share/kursg" ]
then
    res="/usr/local/share/kursg"

else
    #
    # resource not found on the system, assuming portable instalation and that
    # resources are in the same directory as kursg program
    #
    res="$(cd "$(dirname "${0}")" && pwd)"
fi

###
# now we can start building the site
#

cd "${in}"

###
# process all *.md files
#

find . \( -name "*.md" -o -name "*.html" \) -print0 | while IFS= read -r -d $'\0' f
do
    file="$(basename "${f}")"
    dname="$(dirname "${f}")"
    fname="${file%.*}"
    rnum=0
    outfile="${out}/${dname}/${fname}.html"

    if is_ignored "${dname}"
    then
        continue
    fi

    depth="$(echo "${dname}" | tr -cd '/' | wc -c)"
    mkdir -p "${out}/${dname}"
    build_index "${outfile}" "${depth}"

    if [ "${f%.*}" = "${dname}/${fname}" ] && [ -d "${dname}/${fname}" ]
    then
        #
        # currently parsed file (like subsite.md) has corresponding directory
        # (subsite). In such case we need to generate menu for subsite dir to
        # be included in subsite.html file
        #

        dname+="/${fname}"
    fi

    #
    # generate menu tree for file
    #

    dirnum="$(build_menu "${dname}" "${outfile}" "${depth}")"

    #
    # generate html output, if file is html, markdown will happily send
    # unchanged html
    #

    eval "${markdown}" "\"${f}\"" >> "${outfile}"

    #
    # closing all opened <div class="content"> tags
    #

    for (( c=1; c<=$dirnum; c++ ))
    do
        echo '</div>' >> "${outfile}"
    done

    #
    # add footer
    #

    echo "<div id="footer">" >> "${outfile}"
    cat "${in}/footer.in" >> "${outfile}"
    echo "</div>" >> "${outfile}"

    close_index "${outfile}"
done

###
# process all folders that don't have matchin file with content
#

find . -type d -print0 | while IFS= read -r -d $'\0' dir
do
    if is_ignored "${dir}"
    then
        continue
    fi

    cd "${dir}"
    find . -maxdepth 1 -type d -print0 | while IFS= read -r -d $'\0' d
    do
        if [ -f "${d}.md" ] || [ -f "${d}.html" ] || [ "${d}" = "." ]
        then
            ###
            # folder has coresponding source file and it was already parsed
            # earlier, ignoring
            #
            # also we skip if folder name is .
            #

            continue
        fi

        file_name="$(basename "${d}")"
        file_title="$(get_meta_title "${d}")"
        file_index="$(get_kursg_meta "${d}" "index")"
        outfile="${out}/${dir}/${file_name}.html"

        depth="$(echo "${dir}" | tr -cd '/' | wc -c)"
        mkdir -p "${out}/${dir}"
        build_index "${outfile}" "${depth}"
        dirnum="$(build_menu "${dir}/${file_name}" "${outfile}" "${depth}")"

        if [ -z "${file_index}" ]
        then
            ###
            # index file not defined, try to find one to use
            #

            file_index="$(basename "$(find "${d}" -maxdepth 1 -name "*.md" -o -name "*.html" -print -quit)")"
        fi

        if [ -f "${d}/${file_index}" ]
        then
            eval "${markdown}" "\"${d}/${file_index}\"" > /tmp/kursg-file-index
            sed -i '/href=\"\.\.\//I { s/\.\.\//\.\//g }' /tmp/kursg-file-index
            cat /tmp/kursg-file-index >> "${outfile}"
            rm /tmp/kursg-file-index
        fi

        #
        # closing all opened <div class="content"> tags
        #

        for (( c=1; c<=$dirnum; c++ ))
        do
            echo '</div>' >> "${outfile}"
        done

        #
        # add footer
        #

        echo "<div id="footer">" >> "${outfile}"
        cat "${in}/footer.in" >> "${outfile}"
        echo "</div>" >> "${outfile}"

        close_index "${outfile}"
    done
    cd - > /dev/null
done

outbase="$(basename ${out})"
rm "${out}/.kursg-ignore"
rm -f "${out}/${outbase}.html"

#
# copy chosen style and pygment
#

cp "${res}/styles/${in_style}.css" "${out}/style.css"
cp "${res}/pygments/${in_pygment}.css" "${out}/pygment.css"

#
# copy static files to output
#

if [ -f custom.css ]
then
    cp "${in}/custom.css" "${out}"
fi

if [ ! -f static.in ]
then
    #
    # static.in doesn't exist, don't copy anything
    #

    exit 0
fi

IFS=$'\n'
for d in $(cat "static.in")
do
    cp -r "${d}" "${out}"
done
unset IFS
