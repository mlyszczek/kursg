#!/usr/bin/env bash

#  ==========================================================================
#   Licensed under BSD 2clause license. See LICENSE file for more information
#   Author: Michał Łyszczek <michal.lyszczek@bofc.pl>
#  ==========================================================================

#
# functions and stuff
#

function show_help
{
    echo "kursg [options]"
    echo ""
    echo -e "\t-h        print this help message"
    echo -e "\t-i<path>  directory to process"
    echo -e "\t-o>path>  output directory"
    echo -e "\t-d        delete output directory before generating"
}

#
# builds index of all html files
#

function build_index
{
    o=$1  # absolute path to file where index will be printed

    #
    # make all echo redirect to $o file
    #

    exec 1<&-
    exec 1<>"$o"

    #
    # truncate file if it already exists
    #

    truncate -s0 $o

    #
    #
    # build index and meta information from index.in
    #

    echo '<!DOCTYPE html>'
    echo '<html lang="pl">'
    echo '<head>'
    echo '<title>'$in_title'</title>'
    echo '<link rel="stylesheet" type="text/css; charset=utf-8" href="/style.css">'
    echo '<link rel="stylesheet" type="text/css" href="/pygment.css">'

    if [ -f custom.css ]
    then
        echo '<link rel="stylesheet" type="text/css" href="/custom.css">'
    fi

    echo '<meta charset="UTF-8">'
    echo '<meta name="description" content="'$in_description'">'
    echo '<meta name="keywords" content="'$in_keywords'">'
    echo '<meta name="author" content="'$in_author'">'
    echo '</head>'
    echo '<body>'
    echo '<div id="header">'

    #
    # print user defined header (logo or something like that)
    #

    cat header.in

    echo '</div>'

    #
    # restore echo output
    #

    exec &>/dev/tty
}


function close_index
{
    o=$1  # absolute path to file where index will be printed

    echo '</body>' >> $o
    echo '</html>' >> $o

    #
    # restore echo output
    #

    exec &>/dev/tty
}

get_kursg_meta()
{
    file="$1"
    field="$2"

    ext="${file##*.}"
    skip_last_chars=0

    if [ "${ext}" = "md" ]
    then
        tmp=`grep "^\[kursg-meta\]: # (${field}: " "${file}" | awk '{print $4}'`
        skip_last_chars=1
    elif [ "${ext}" = "html" ] || [ "${ext}" = "htm" ]
    then
        tmp=`grep "^<\!-- \[kursg-meta:${field}\]" "${file}" | cut -f3- -d\ `
        skip_last_chars=4
    else
        ###
        # file extension not recognized, exit
        #

        return
    fi

    if [ -z "${tmp}" ]
    then
        ###
        # field wasn't found, return nothing
        #
        return
    fi

    ###
    # echo value and strip trailing ')'
    #

    echo ${tmp:0:-${skip_last_chars}}
}

get_menu_name()
{
    file=$1

    title=`get_kursg_meta "$file" "title"`

    if [ ! -z "${title}" ]
    then
        echo "${title}"
        return
    fi

    ###
    # title wasn't set in file, use first h1 element (one with ===)
    #

    title=`cat $file | grep "^=" -m1 -C1 | head -n1`

    if [ ! -z "${title}" ]
    then
        echo "${title}"
        return
    fi

    ###
    # title wasn't set in file, out last hope is filename
    #

    basefile=`basename ${file}`
    echo ${basefile%.*}
}

get_file_index()
{
    file="$1"

    index=`get_kursg_meta "$file" "index"`

    if [ -z "${index}" ]
    then
        ###
        # index was not set, apply maximum possible index and let it be sorted
        # alphabetically, after files that have index set
        #

        echo "9999"
        return
    fi

    printf "%04d" "${index}"
}

build_menu()
{
    dname=$1
    outfile=$2

    menu=
    dir=
    dirnum=0

    IFS=$'/'
    for d in $dname
    do
        dir+="$d"
        ((dirnum++))

        menu+='<div class="menu">'
        menu+='<ul class="menu">'
        menu_links=

        cd "$dir"
        find . -maxdepth 1 \( -name "*.md" -o -name "*.html" \) -print0 | while IFS= read -r -d $'\0' f
        do
            f=`basename "${f}"`
            menu_name=`get_menu_name "${f}"`
            md_index=`get_file_index "${f}"`
            md_name=${f%.*}
            path=$(echo "$dir/${md_index}-${md_name}.html" | cut -c2-)
            echo -n "<li class=\"menu\"><a class=\"menu\" href=\"$path\">" >> /tmp/kursg-menu
            echo "$menu_name</a></li>" >> /tmp/kursg-menu
        done
        cd - > /dev/null

        menu+=`cat /tmp/kursg-menu | sort`
        menu+='</ul>'
        menu+='</div>'
        menu+='<div class="content">'
        dir+='/'
        rm /tmp/kursg-menu
    done
    IFS=

    echo $menu >> $outfile

    ###
    # return number of created <div class="content"> so upper layer can
    # close them all later when it has filled content with data
    #

    echo $dirnum
}


################################################################################
# the real code starts here
################################################################################


#
# parse input parameters
#

out="$(pwd)/kurwigen_out"
in="$(pwd)"
delete=0
OPTIND=1

while getopts "h?i:o:d" opt
do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;

    i)
        in="$OPTARG"
        ;;

    o)
        out="$OPTARG"
        ;;

    d)
        delete=1
        ;;



    esac
done

#
# source config file
#

. $in/index.in

#
# checking for program
#

markdown_extensions="-x markdown.extensions.fenced_code -x markdown.extensions.codehilite -x markdown.extensions.toc -x markdown.extensions.admonition -x markdown.extensions.tables"
markdown=$(which markdown_py)

if [ ! -x "$markdown" ]
then
    echo "python markdown (markdown_py) was not found on the system"
    exit 1
fi

markdown="$markdown $markdown_extensions"

#
# sanity check of output directory
#

if [ $delete = 1 ]
then
    echo "do you want to delete $out directory recursively?"
    read answer

    if [ "x$answer" = "xyes" ]
    then
        rm -rf $out
    fi
fi

[ -d $out ] || mkdir $out

#
# look for resource directory
#

res=

if [ -d "/usr/share/kursg" ]
then
    res="/usr/share/kursg"

elif [ -d "/usr/local/share/kursg" ]
then
    res="/usr/local/share/kursg"

else
    #
    # resource not found on the system, assuming portable instalation and that
    # resources are in the same directory as kursg program
    #
    res="$(cd "$(dirname "${0}")" && pwd)"
fi

###
# now we can start building the site
#

cd $in

###
# process all *.md files
#

find . \( -name "*.md" -o -name "*.html" \) -print0 | while IFS= read -r -d $'\0' f
do
    file=$(basename "$f")
    dname=$(dirname "$f")
    fname=${file%.*}
    rnum=0
    file_index=`get_file_index "$f"`
    outfile="${out}/${dname}/${file_index}-${fname}.html"

    mkdir -p $out/$dname

    build_index $outfile

    if [ "${f%.*}" = "$dname/$fname" ] && [ -d "$dname/$fname" ]
    then
        #
        # currently parsed file (like subsite.md) has corresponding directory
        # (subsite). In such case we need to generate menu for subsite dir to
        # be included in subsite.html file
        #

        dname+="/$fname"
    fi

    #
    # generate menu tree for file
    #

    dirnum=`build_menu "${dname}" "${outfile}"`

    #
    # generate html output, if file is html, markdown will happily send
    # unchanged html
    #

    eval $markdown $f >> $outfile

    #
    # closing all opened <div class="content"> tags
    #

    for (( c=1; c<=$dirnum; c++ ))
    do
        echo '</div>' >> $outfile
    done

    #
    # add footer
    #

    echo "<div id="footer">" >> $outfile
    cat footer.in >> $outfile
    echo "</div>" >> $outfile

    close_index $outfile
done

#
# copy chosen style and pygment
#

cp $res/styles/$style.css $out/style.css
cp $res/pygments/$pygment.css $out/pygment.css

#
# copy static files to output
#

if [ -f custom.css ]
then
    cp custom.css $out
fi

if [ ! -f static.in ]
then
    #
    # static.in doesn't exist, don't copy anything
    #

    exit 0
fi

IFS=$'\n'
for d in $(cat "static.in")
do
    cp -r $d $out
done
unset IFS
